\input{macros/macros}

\section{Recursive Proofs of Knowledge}

In this lecture, 
we discuss recursive zero-knowledge succinct non-interactive
arguments of knowledge (zkSNARKs).
%
We assume familiarity with zkSNARKs.

\subsection{Introduction}

% Zero-Knowledge Proofs
Succinct non-interactive arguments of knowledge are short certificates that attest to the correct execution of a computation without revealing any secret inputs. 
%
Today, 
zero-knowledge proofs are being used 
to secure \emph{billions} of dollars worth of assets~\cite{zerocash, stark}.
%
Zero-knowledge proofs 
enable a new class of secure applications 
with enhanced integrity and privacy guarantees
such as verifiable databases~\cite{zkvsql, vsql, accountablestorage, integridb},
private voting protocols~\cite{privatevoting},
anonymous credentials~\cite{cinderella, dacreds},
and
private cryptocurrencies~\cite{zerocash, pinocchiocoin, stark}.

% Proving a Function
More technically, 
SNARKs 
(for circuit-satisfiability)
allow a prover to demonstrate that it knows a secret witness $w$
such that for prescribed circuit $F$ and prescribed input and output pair $(x, y)$ that $F(x, w) = y$.
%
% Proving Recursion
However, today, we will be interested in
proving \emph{recursive} computation. 
Without loss of generality, we are interested in proving \emph{tail}
recursion,
that is, we want to prove
(unbounded) recursive applications 
of a function $F$.
Unbounded recursion
in general allows us to implement more complex programming patterns such as 
$\mathsf{for}$ and $\mathsf{while}$, 
which are not bounded ahead of time.
This allows us to prove stateful computations with dynamic control flow.
%% Use cases
In practice, 
proving recursion allows us to recursively prove blockchain updates, verifiable delay functions, and even a universal machine,
where each recursive step is a single cycle of a CPU.


% Naive Solution
Historically, 
the best known approach to design a proof system for recursive applications of a function $F$ 
was to unroll the entire execution $F \circ F \circ \cdots \circ F$ into a monolithic arithmetic circuit,
and then use a standard proof system with succinct proofs for circuit satisfiability.
%
Unfortunately,
this would necessarily mean that the prover's space complexity would scale with the \emph{entire trace} of the computation.
%
Moreover, 
in the setting of preprocessed arguments of knowledge
(where the prover and verifier would process the circuit into a succinct key to use for multiple inputs)
this fixed the recursion-depth ahead of time,
which often does not reflect practice.

% Recursive Solution Overview
The first breakthrough was due to Valiant~\cite{valiant} in 2012, 
who proposed incrementally verifiable computation (IVC),
which reflected the recursive structure of the computation
into the proof itself:
%
Given a succinct proof $\pi_{i}$ attesting to $i$ steps of computation,
the prover can write a succinct proof $\pi_{i + 1}$ that attests to $i + 1$ steps
by proving the correct execution of an arithmetic circuit 
that runs the latest step of computation,
and checks $\pi_i$ 
(using the proof system's verifier).
This avoids having to fix the recursion depth ahead of time,
while ensuring that the prover's space complexity only scales with a single step of execution.

Although undoubtedly elegant, 
Valiant's technique introduces a subtle issue:
Proofs of knowledge must satisfy a stronger notion of soundness 
known as \emph{knowledge-soundness}.
%
Essentially,
a proof system is considered knowledge-sound 
if, 
for any successful prover with some secret input to the computation, 
there exists a corresponding \emph{extractor} that,
with at most polynomial overhead,
can retrieve this secret input given access to the ``source code'' of the prover.
%
This extractor-based definition becomes problematic in the recursive setting:
Recursive proofs require \emph{recursive extraction} 
in which the extractor for step $i$ 
plays the successful prover for the extractor at step $i - 1$. 
This incurs a polynomial blowup in the extractor for each successive recursive step. 
In particular, 
this results in a final extractor that runs in exponential-time with respect to the recursion-depth, 
which disqualifies it as a valid extractor. 
%
To account for this issue, 
Valiant's original technique 
(and modern techniques) 
can only provably guarantee logarithmic-depth recursion in standard models.

\section{Preliminaries}

% Definition
\input{definitions/ivc}
\input{definitions/nark}
\input{definitions/nark_succinctness}
\input{definitions/commitment}
\input{definitions/csat}

\section{Construction}

% Formal Construction
\input{constructions/ivc}


\begin{lemma}[Completeness]
 Construction~\ref{cons:ivc}
 is complete.
\end{lemma}
\newcommand{\proof}{\noindent{\bf Proof. }} %% To begin a proof write \proof

\begin{proof}
   % Adversary
 Consider arbitrary PPT adversary $\mathcal{A}$.
 % public parameters
 Suppose $\pp \gets \Gen(1^{\lambda}, N)$.
 % Structure, Instance, Witness
 Suppose that
 \[
 (F, (z_0, z_i, i), \pi_i) \gets \mathcal{A}(\pp).
 \]
 % Prover Key, Verifier Key
 Suppose that for
   $(\pk, \vk) \gets \En(\pp, F)$
 % Precondition
 we have that
 \begin{align}\label{ivc:completeness:precondition:verifier}
   \V(\vk, (z_0, z_{i}, i), \pi_{i}) = 1.
 \end{align}
 % Postcondition
 Then,
 given
 \begin{align*}
   z_{i + 1} \gets F(z_{i}, \omega_{i})
 \end{align*}
 and 
 \begin{align*}
   \pi_{i + 1} \gets \Po(\pk, (z_0, z_i, i), (\omega_i, \pi_i))
 \end{align*}
 we must show that
 \begin{align}\label{ivc:completeness:postcondition}
   \V(\vk, (z_0, z_{i+1}, N), \pi_{i + 1}) = 1
 \end{align}
 with probability $1$.
 %
 
 % Case i = 0
 Indeed, 
 consider the base case where $i = 0$.
 %
 Then, 
 by Precondition~\ref{ivc:completeness:precondition:verifier},
 by the verifier's check in the base case 
 (Step~\ref{ivc:verifier:base})
 we have that $z_0 = z_i$.
 %
 Therefore,
 $\Po$ can successfully compute $\io_{i + 1}$ 
 (Step~\ref{ivc:prover:io}),
 because the base case check of $\FP$ 
 (Step~\ref{ivc:fp:base}) passes.
 %
 Then,
 by construction of $\FP$
 (Step~\ref{ivc:fp:output})
 we have that 
 \[
   \io_{i + 1} = (\vk_{\snark}, i + 1, z_0, F(z_i, \omega_i))
 \]
 Moreover,
 by the completeness
 of $\snark$,
 we have that $\pi_{i + 1}$ generated by $\Po$ 
 (Step~\ref{ivc:prover:proof})
 is indeed satisfying.
 %
 Therefore, 
 both the checks of $\V$ in Steps~\ref{ivc:v:check:first} and~\ref{ivc:v:check:second}
 are passing.
 %
 As such,
 we have that postcondition~\ref{ivc:completeness:postcondition}
 holds.
 
 
 % Case i \geq 1
 Suppose instead that $i \geq 1$.
 %
 by Precondition~\ref{ivc:completeness:precondition:verifier},
 by the verifier's check in the general case 
 we have that
 \begin{align*}
   \snark.\V(\vk_\snark, (\bot, \io_i), \pi_i) = 1
 \end{align*}
 for $\io_i = (\vk_\snark, i, z_0, z_i)$.
 %
 Then,
 $\Po$ can successfully compute $\io_{i + 1}$ 
 (Step~\ref{ivc:prover:io}),
 as the SNARK verifier check in $\FP$
 (Step~\ref{ivc:fp:check:general})
 holds.
 %
 %
 Once again,
 by construction of $\FP$
 (Step~\ref{ivc:fp:output})
 we have that 
 \[
   \io_{i + 1} = (\vk_{\snark}, i + 1, z_0, F(z_i, \omega_i))
 \]
 Moreover,
 by the completeness
 of $\snark$,
 we have that $\pi_{i + 1}$ generated by $\Po$ 
 (Step~\ref{ivc:prover:proof})
 is indeed satisfying.
 %
 Therefore, 
 both the checks of $\V$ in Steps~\ref{ivc:v:check:first} and~\ref{ivc:v:check:second}
 are passing.
 %
 As such,
 we have that postcondition~\ref{ivc:completeness:postcondition}
 holds.
\end{proof}

\begin{lemma}[Knowledge-Soundness]
 Construction~\ref{cons:ivc}
 is knowledge-sound.
\end{lemma}

% Proof for ivc knowledge soundness

\begin{proof}
   % Premise
   Let $n$ be a global constant.
   %
   Consider a deterministic expected polynomial-time adversary $\Po^*$.
   %
   Let $\pp \gets \Gen(1^{\lambda}, N)$.
   %
   Suppose 
   on input $\pp$ and randomness $\mathsf{r}$,
   $\Po^*$
   outputs 
   polynomial-time function $F$,
   instance $(z_0, z)$,
   and IVC proof $\pi$. 
   %
   Let $(\pk, \vk) \gets \En(\pp, F)$.
   Suppose that
   % Precondition
   \begin{align*}
     \V(\vk, (z_0, z, n), \pi) = 1.
   \end{align*}
   % Postcondition
   We must construct an expected polynomial-time extractor $\mathcal{E}$
   that, 
   with input $(\pp, \mathsf{r})$,
   outputs $(\omega_0, \ldots, \omega_{n - 1})$ 
   such that by computing
   \begin{align*}
     z_{i + 1} \gets F(z_{i}, \omega_{i})
   \end{align*}
   we have that $z_n = z$ with probability 
   $1 - \negl{\lambda}$.
   
   % Overview
   We show inductively that we can construct an expected polynomial-time extractor $\mathcal{E}_i$ that outputs 
   $((z_i, \ldots, z_{n - 1}), (\omega_i, \ldots, \omega_{n - 1}), \pi_i)$ such that for all $j \in  \{i + 1, \ldots, n\}$,
   \begin{align*}
     z_j = F(z_{j - 1}, \omega_{j - 1})
   \end{align*}
   and 
   \begin{align}\label{eq:ih:2}
     \V(\vk, z_0, z_i, \pi_i) = 1
   \end{align}
   for $z_n = z$ with probability $1 - \negl{\lambda}$.
   %
   Then, 
   because when $i = 0$,
   $\V$ checks that $z_0 = z_i$ 
   the values $(\omega_0, \ldots, \omega_{n - 1})$ 
   retrieved by $\mathcal{E} = \mathcal{E}_0$
   are such that computing  
   $z_{i + 1} = F(z_i, \omega_i)$ for all $i \geq 1$ gives $z_n = z$.
   
   At a high level,
   to construct an extractor $\mathcal{E}_{i - 1}$,
   we first assume the existence of $\mathcal{E}_i$ that satisfies the inductive hypothesis. 
   We then use $\mathcal{E}_i$ to construct an adversary 
   for the underlying succinct non-interactive argument, which we denote as $\widetilde{\Po}_{i - 1}$.
   This in turn guarantees an extractor for the underlying non-interactive argument,
   which we denote as $\widetilde{\mathcal{E}}_{i - 1}$. 
   We then use $\widetilde{\mathcal{E}}_{i - 1}$ to construct $\mathcal{E}_{i - 1}$ that satisfies the inductive hypothesis.
   
   
   % Base case
   In the base case,
   let $\mathcal{E}_n(\pp, \mathsf{r})$ 
   output 
   $(\bot, \bot, \pi_n)$ 
   where $\pi_n$ is the output of 
   $\Po^*(\pp, \mathsf{r})$.
   By the premise,
   we have that $\pi_n$ is satisfying.
   As such,
   $\mathcal{E}_n$ succeeds with probability $1 - \negl{\lambda}$ in expected polynomial-time.
   
   % Inductive Step
   For $i \geq 1$, 
   suppose we can construct an expected polynomial-time extractor 
   $\mathcal{E}_i$ 
   that outputs
   $((z_i, \ldots, z_{n - 1}), (\omega_i, \ldots, \omega_{n - 1}))$, 
   and $\pi_i$ 
   that satisfies the inductive hypothesis.
   % Construct SNARK prover
   To construct an extractor $\mathcal{E}_{i - 1}$, 
   we first construct an adversary $\widetilde{\Po}_{i - 1}$
   for the underlying SNARK as follows.
   %
   %
   %
   \begin{mdframed}[nobreak=true]
     \noindent \underline{$\widetilde{\Po}_{i - 1}(\pp, \mathsf{r})$}: 
     \begin{enumerate}
       \item Let $(F, z_0) \gets \Po^*(\pp, \mathsf{r})$
       \item Let $((z_i, \ldots, z_{n - 1}), (\omega_i, \ldots, \omega_{n -
       1}), \pi_i) \gets \mathcal{E}_i(\pp, \mathsf{r})$.
       \item Let $\vk_{\snark} \gets \snark.\En(\pp, F)$.
       \item Let $\io_i \gets (\vk_\snark, (i, z_0, z_i))$.
       \item Output $(\FP, (\bot, \io_i), \pi_i)$.
     \end{enumerate}
   \end{mdframed}
   
   % SNARK prover success probability
   We now analyze the success probability of $\widetilde{\Po}_{i - 1}$. 
   By the inductive hypothesis,
   we have that 
   \[
   \V(\vk, z_0, z_i, \pi_i) = 1,
   \]
   where 
   $\pi_i \gets \mathcal{E}_i(\pp, \mathsf{r})$ 
   with probability 
   $1 - \negl{\lambda}$.
   Therefore, 
   by the the verifier's checks 
   we have that
   \[
   \snark.\V(\vk_\snark, (\bot, \io_i), \pi_i) = 1
   \]
   for $\io_i = (\vk_\snark, (i, z_0, z_i))$
   and $\vk_\snark \gets \snark.\En(\pp, \FP)$.
   Therefore,
   $\widetilde{\Po}_{i - 1}$
   succeeds in producing a satisfying proof $\pi_i$
   for structure $\FP$ and instance $\io_i$
   with probability $1 - \negl{\lambda}$.
 
   
   % Corresponding SNARK extractor
   Then,
   by the knowledge soundness of $\snark$
   there exists an 
   expected-polynomial-time
   extractor $\widetilde{\mathcal{E}}_{i - 1}$ that
   outputs 
   $(\io_{i - 1}, \omega_{i - 1}, \pi_{i - 1})$
   such that
   $\io_i = \FP(\io_{i - 1}, \omega_{i - 1}, \pi_{i - 1})$
   with probability $1 - \negl{\lambda}$.
   
   % Constructing E_{i - 1}
   Given $\widetilde{\mathcal{E}}_{i - 1}$, 
   we construct an expected polynomial time $\mathcal{E}_{i - 1}$ as follows.
 
 
   \begin{mdframed}[nobreak=true]
   \noindent \underline{$\mathcal{E}_{i - 1}(\pp, \mathsf{r})$}: 
   \begin{enumerate}
     \item Run $\widetilde{\Po}_{i - 1}(\pp, \mathsf{r})$
     to parse
     \[
     ((z_i, \ldots, z_{n - 1}), (\omega_i, \ldots, \omega_{n -
     1}), \pi_i)
     \]
     from its internal state.
     \item Compute $(\io_{i - 1}, \omega_{i - 1}, \pi_{i - 1}) \gets \widetilde{\mathcal{E}}_{i - 1}(\pp, \mathsf{r})$.
     \item Parse $(\vk_\snark, (i - 1, z_0, z_{i - 1})) \gets \io_{i - 1}$
     \item Output $((z_{i - 1}, \ldots, z_{n - 1}), (\omega_{i - 1}, \ldots, \omega_{n - 1}), \pi_{i - 1})$. 
   \end{enumerate}
 \end{mdframed}
 
  We now reason about the success probability of $\mathcal{E}_{i - 1}$.
   We first reason that the output $(z_{i - 1}, \ldots, z_{n - 1})$, and
   $(\omega_{i - 1}, \ldots, \omega_{n - 1})$ are valid.
   By the inductive hypothesis, 
   we already have that for all $j \in \{i + 1, \ldots, n\}$,
   \begin{align*}
     z_j = F(z_{j - 1}, \omega_{j - 1})
   \end{align*}
   with probability $1 - \negl{\lambda}$.
   Moreover,
   by the success probability of $\mathcal{E}_{i - 1}$,
   we have that
   \begin{align*}
     z_{i} = F(z_{i - 1}, \omega_{i - 1})
   \end{align*}
   and that
   \[
   \snark.\V(\vk_\snark, \io_{i - 1}, \pi_{i - 1}) = 1
   \]
   where $\io_{i - 1} = (\vk_\snark, (i - 1, z_0, z_i))$
   with probability $1 - \negl{\lambda}$.
   %
   Therefore we have that $\mathcal{E}_{i - 1}$
   succeeds with probability $1 - \negl{\lambda}$
   satisfying the inductive hypothesis.
 \end{proof} 

% \bibliographystyle{style/splncs04}
% \bibliography{references/references}
