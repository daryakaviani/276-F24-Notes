\begin{definition}
    [Incrementally Verifiable Computation]\label{def:ivc}
    An 
    incrementally verifiable computation (IVC)  
    scheme is defined by
    PPT algorithms 
    $(\mathcal{G}, \mathcal{P}, \mathcal{V})$ 
    and deterministic $\En$
    denoting the generator, 
    the prover, 
    the verifier,
    and the encoder respectively,
    with the following interface
    \begin{itemize}
      \item $\mathcal{G}(1^\lambda, N) \to \pp$: 
      on input security parameter $\lambda$ and size bounds $N$, 
      samples public parameters $\pp$.
      \item $\En(\pp, F) \to (\pk, \vk)$: 
      on input public parameters $\pp$, 
      and polynomial-time function $F$,
      deterministically produces
      a prover key $\pk$ 
      and a verifier key $\vk$.
      \item $\mathcal{P}(\pk, (i, z_0, z_{i}), \omega_{i}, \pi_{i}) \to \pi_{i+1}$: 
      on input a prover key $\pk$, 
      a counter $i$, 
      an initial input $z_0$, 
      a claimed output after $i$ iterations $z_i$,
      a non-deterministic advice $\omega_i$,
      and an IVC proof $\pi_i$ attesting to $z_i$,
      produces a new proof $\pi_{i + 1}$ attesting to $z_{i + 1} = F(z_{i}, \omega_{i})$.
      \item $\mathcal{V}(\vk, (i, z_0, z_{i}), \pi_{i}) \to \{0, 1\}$: 
      on input a verifier key $\vk$,
      a counter $i$,
      an initial input $z_0$, 
      a claimed output after $i$ iterations $z_i$,
      and an IVC proof $\pi_i$ attesting to $z_i$,
      outputs $1$ if $\pi_i$ is accepting, and 
      $0$ otherwise.
    \end{itemize}
      An IVC scheme 
      $(\mathcal{G}, \En, \mathcal{P}, \mathcal{V})$
      satisfies the following requirements.
      \begin{enumerate}
      \item Perfect Completeness:    
      For any
      PPT adversary $\mathcal{A}$
      \begin{equation*}
      \Pr
      \left[
        \begin{array}{l}
          \mathcal{V}(\vk, (i + 1, z_0, z_{i + 1}), \pi_{i + 1}) = 1 
        \end{array}
        \middle\vert
        \begin{array}{l}
          \mathsf{pp} \gets \mathcal{G}(1^{\lambda}, N),\\
          (F, (i, z_0, z_i), (\omega_i, \pi_i)) \gets \mathcal{A}(\mathsf{pp}),\\
          (\pk, \vk) \gets \En(\pp, F),\\
          z_{i + 1} \gets F(z_{i}, \omega_{i}),\\
          \mathcal{V}(\vk, i, z_0, z_{i}, \pi_{i}) = 1,\\
          \pi_{i + 1} \gets \mathcal{P}(\pk, (i, z_0, z_i), (\omega_{i}, \pi_{i}))
        \end{array}
      \right] = 1
      \end{equation*}
      where $F$ is a polynomial-time computable function represented as an arithmetic circuit.
    \item Knowledge Soundness:
    Consider constant $n \in \mathbb{N}$.
    \niksdef
    % Structure
    {F} 
    % Statement
    {(z_0, z_i)}
    % Witness
    {(\omega_0, \ldots, \omega_{n - 1})}
    % Proof Format
    {\Pi}
    % Precondition
    {\mathcal{V}(\vk, (n, z_0, z), \Pi) = 1}
    % Postcondition
    {z_n = z \text{ where }\\ z_{i + 1} \gets F(z_i, \omega_i)\\
    \forall i \in \{0, \ldots, n - 1\}
    }
    Moreover, 
      $F$ is a polynomial-time computable function represented as an arithmetic circuit.
      \item Succinctness: 
      The size of an IVC proof $\pi$ is independent of the number of iterations $i$.
    \end{enumerate}
\end{definition}